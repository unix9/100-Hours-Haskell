<!--?xml version="1.0" encoding="iso-8859-1"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Programming Language Concepts ( COMP2212 )</title>
  <link href="ProblemSheet1_files/proglangconc.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="header">
<h1>Programming Language Concepts ( COMP 2212 )</h1>
<h1>Semester Two, 2022</h1>
<home><a href="https://secure.ecs.soton.ac.uk/notes/comp2212/index.html">Home</a></home>
</div>

<div class="notes">

<h2>Exercise Sheet One: Refresher on Haskell and Working with Files</h2>

<p>
The aim of this exercise class is to make sure you are up to speed in 
the Haskell language. 
We will simply be revising some of the core Haskell features such as 
polymorphism, higher-order functions, lists and pattern matching. We 
will also be making use of Haskell I/O features for reading and writing 
files.
</p>

<p>
  By the end of this sheet you should be comfortable with reading and 
writing files using Haskell I/O and you should be able to compile a 
standalone Haskell application. 
</p>

<p>
Work on the exercises independently or in groups and if you run in to 
difficulty then use the Friday lab session to ask any questions you have
 about the them. 
</p>


<exno>Task One ( Easy warm up )</exno>

<p>
Write an Haskell function called <tt>zipL</tt> that takes a pair of <tt>[Int]</tt> arguments. 
If the lists are of the same length <tt>zipL</tt> should return a list of lists of Ints - each of which are exactly two elements long.  The first element of each list
should come from the first input list and the second element of each list 
should come from the second input list.
</p>
<p>
For example, <tt>zipL ([1,2,3,4],[5,6,7,8])</tt> should return 
<tt>[[1,5],[2,6],[3,7],[4,8]]</tt>
</p>

<p>Remember: begin by writing the type of the function</p>

<p>
Write an Haskell function called <tt>unzipL</tt> 
that takes a list of two elements lists of <tt>Int</tt> values and returns a pair of 
lists such that 
</p><blockquote>
<tt> unzipL ( zipL ( list1, list2 ) ) </tt> returns <tt>( list1, list2 )</tt>
</blockquote>
for any <tt>[Int]</tt> values <tt>list1</tt> and <tt>list2</tt> of the same length. 
<p></p>

<p>
Similarly, check that your solution always returns <tt>list2e</tt> (for any list of two <tt>Int</tt> element lists <tt>list2e</tt>) when evaluating  <tt> zipL ( unzipL ( list2e ) ) </tt>.
</p>

<p>
Now, if you haven't already, generalise your solution to work for lists of any type rather than just <tt>Int</tt>.
</p>


<exno>Task Two (A bit harder)</exno>

<p>
In Task One, when writing <tt>zipL</tt> we were allowed to assume that the lists were the same length. Rewrite <tt>zipL</tt>
 for input lists of possibly different lengths.  This means that in the 
output list of lists we may no longer have exclusively two element 
lists. This also means that we can't return a list of pairs. Let's 
return a list of lists of at most two elements instead.  
</p>
<p>
Rewrite <tt>zipL</tt> with the type <tt>zipL :: [Int] -&gt; [Int] -&gt; [[Int]]</tt>
</p>
<p>
For example, <tt>zipL [1,2,3,4] [5,6]</tt> should return 
<tt>[[1,5],[2,6],[3],[4]]</tt> and 
<tt>zipL [1,2] [5,6,7,8]</tt> should return 
<tt>[[1,5],[2,6],[7],[8]]</tt>
</p>

<p>Is it possible to write the inverse function <tt>unzipL</tt> in this case?</p>

<exno>Task Three (More challenging)</exno>

<p>
There is no reason to restrict <tt>zipL</tt> from Task Two to just two input lists. 
Write a function called <tt>multiZipL :: [[a]] -&gt; [[a]]</tt> that 
accepts a list of lists
and produces a "zipped" version of these lists by taking consecutive 
elements from each of the input lists to form the next output list. 
</p>
<p>
For example, 

<br>
<tt>multiZipL [[1,2,3],[4,5,6],[7,8,9]]</tt> should return 
<br>
<tt>[[1,4,7],[2,5,8],[3,6,9]]</tt>
and 
<br>
<br>
<tt>multiZipL [[1,2,3],[4,5,6],[7,8,9],[10],[11],[12,13,14,15]]</tt> should return 
<br>
<tt>[[1,4,7,10,11,12],[2,5,8,13],[3,6,9,14],[15]]</tt>
</p>

<exno>Task Four</exno>

<p>
Let's generalise your function from Task Three to use some I/O (you could also use <tt>zipL</tt> from Task Two if you didn't manage to complete Task Three).  Write a function <tt>multiZipF :: String -&gt; String -&gt; IO ()</tt>
 that accepts the String names of two CSV files. The first file should 
contain a list of integers on each line, the function should then zip 
the lists as per Task Three and write the output to the second CSV file.
 
</p>

<p>
Create a Haskell application that has a main function that calls <tt>multiZipF</tt>. To keep it simple at this stage you can used a fixed filename for the input and output files.  Remember to compile this using <tt>ghc</tt> as a standalone application. You are not running this in interactive mode and should not use <tt>ghci</tt>.
</p>

<exno>Task Five</exno>

<p>
  Look up the function <tt>System.Environment.getArgs</tt> in Hackage.
</p>
<p>
Use this function to modify your solution from Task Four to create an 
Haskell application that accepts the names of an source and target CSV 
file on the command line instead of using fixed filenames.
</p>

<exno>Task Six</exno>
<p>
Look up the function <tt>Control.Exception.catch</tt> in Hackage.
</p>
<p>
  Use this function to modify your solution to Task Five to provide 
suitable error handling. E.g. catch cases where the files don't exist, 
won't open, or if file contains junk data (i.e. non integers) etc.
</p>



</div><div class="footer">
Page maintained by Julian Rathke.
</div>
 

</body></html>